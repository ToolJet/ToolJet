import _ from 'lodash';
import { v4 as uuidv4 } from 'uuid';

export default function autogenerateColumns(
  tableData,
  existingColumns,
  columnDeletionHistory,
  useDynamicColumn,
  dynamicColumn = [],
  setProperty
) {
  if (useDynamicColumn) {
    if (dynamicColumn.length > 0 && dynamicColumn[0].name) {
      const generatedColumns = dynamicColumn.map((item) => {
        return {
          ...item,
          id: uuidv4(),
          name: item?.name,
          key: item?.key || item?.name,
          autogenerated: true,
        };
      });
      return generatedColumns;
    }
    return [];
  }

  const firstRow = tableData?.[0] ?? {};

  // mapping the keys of first row with one level of nested elements.
  const keysOfTableData = Object.entries(firstRow).reduce((accumulator, currentValue) => {
    /*
    if currentValue[1] type is particularly object, that means it has nested data, so 
    we trygo inside the if statrment to check it's depth and support auto generation of
    columns till one level.
     */
    if (typeof currentValue[1] === 'object' && !Array.isArray(currentValue[1])) {
      accumulator.push(
        ...Object.entries(currentValue[1]).reduce((acc, cv) => {
          /*
            to only support one level of nesting, we are checking condition, if type of cv[1] value is 
            premitive data type or array particulary, if it satisfies any one of the condition, then we auto 
            generate column for it. Else, if it comes out to be object,that means it has more than one level
            of nexted data, so we do not auto generate column for the same.
            */
          if (typeof cv[1] !== 'object' || Array.isArray(cv[1])) {
            acc.push(`${currentValue[0]}.${cv[0]}`);
          }
          return acc;
        }, [])
      );

      return accumulator;
    }
    accumulator.push(currentValue[0]);
    return accumulator;
  }, []);

  const keysOfExistingColumns = existingColumns.map((column) => column.key || column.name);

  const keysFromWhichNewColumnsShouldBeGenerated = _.difference(keysOfTableData, [
    ...keysOfExistingColumns,
    ...columnDeletionHistory,
  ]);

  const keysAndDataTypesToGenerateNewColumns = keysFromWhichNewColumnsShouldBeGenerated?.map((key) => [
    key,
    typeof firstRow[key],
  ]);

  const keysOfExistingColumnsThatNeedToPersist = existingColumns
    .filter((column) => !column.autogenerated || keysOfTableData.includes(column.key || column.name))
    .map((column) => column.key || column.name);

  const generatedColumns = keysAndDataTypesToGenerateNewColumns.map(([key, dataType]) => ({
    id: uuidv4(),
    name: key,
    key: key,
    columnType: convertDataTypeToColumnType(dataType),
    autogenerated: true,
  }));

  const finalKeys = [...keysFromWhichNewColumnsShouldBeGenerated, ...keysOfExistingColumnsThatNeedToPersist];
  const finalColumns = [...existingColumns, ...generatedColumns].filter((column) =>
    finalKeys.includes(column.key || column.name)
  );

  setTimeout(() => setProperty('columns', finalColumns), 10);
}

const dataTypeToColumnTypeMapping = {
  string: 'string',
  number: 'number',
};

const convertDataTypeToColumnType = (dataType) => {
  if (Object.keys(dataTypeToColumnTypeMapping).includes(dataType)) return dataTypeToColumnTypeMapping[dataType];
  else return 'default';
};
