# Apps Page Architecture Documentation

## Overview

The Apps Page is a modern, design-system-driven page component that displays a list of applications and modules in a table/grid view. It follows a strict separation of concerns pattern: pure presentational components, data transformation layer, and adapter components that bridge existing HomePage state to the new UI.

## Architecture Principles

### 1. Separation of Concerns
- **Design System Layer**: Pure UI components with no business logic
- **Feature Layer**: Hooks and containers that handle data and state
- **Adapter Layer**: Bridges existing HomePage state to new UI components
- **Service Layer**: API contracts and data transformation

### 2. Presentational Components (Pure UI)
- Accept props only, no side effects
- No data fetching, no global state access
- No permission checks inside components
- Composable and reusable

### 3. Container Pattern
- Single responsibility: wire hooks and pass props
- Thin wrappers that connect data to UI
- No business logic in containers

### 4. Hook Pattern
- Business logic extracted to reusable hooks
- Testable in isolation
- Composable and shareable

## Component Hierarchy

```
AppsPageAdapter (Adapter - bridges HomePage)
  └─ useAppsPageAdapter (Hook - logic)
      ├─ transformAppsToAppRow (Data transformer)
      ├─ useAppsTableState (Table state hook)
      └─ appsColumns (Column factory)
  └─ AppsShellView (Layout shell)
      ├─ AppsPageLayout (Search, layout)
      └─ PageContainer (Content wrapper)
          ├─ ResourcePageHeader (Title, create buttons)
          └─ AppsTabs (Tabbed content)
              ├─ AppsPageViewHeader (View switcher, filters)
              └─ AppsTable/AppsGrid (Data display)
```

## File Structure

```
frontend/src/components/AppsPage/
├── AppsShellView.jsx              # Layout shell with contentSlot
├── AppsTabs.jsx                   # Tabbed content (apps/modules)
├── ResourcePageHeader.jsx             # Header with create buttons
├── AppsPageViewHeader.jsx         # View switcher and filters
├── AppsTable.jsx                  # Table renderer
├── AppsGrid.jsx                   # Grid renderer
├── PageContainer.jsx              # Content container with footer
├── TablePaginationFooter.jsx      # Pagination controls
├── AppsPage.columns.js            # Column factory
├── AppsPageAdapter.jsx            # Adapter component for HomePage integration
├── AppsPageContainer.stories.jsx  # Storybook stories (Container)
├── AppsPageAdapter.stories.jsx    # Storybook stories (Adapter)
├── INTEGRATION.md                 # Integration guide
├── LLM.txt                        # This file
└── data.json                      # Mock data for stories

frontend/src/features/apps/
├── hooks/
│   ├── useAppsQuery.js            # Data fetching hook (static for now)
│   ├── useAppsPermissions.js      # Permission checks hook
│   ├── useAppsTableState.js       # Table state management
│   ├── useAppsUrlState.js         # URL state sync
│   └── useAppsPageAdapter.js      # Adapter logic hook
├── containers/
│   └── AppsPageContainer.jsx      # Container component
└── adapters/
    └── homePageToAppRow.js        # Data transformer

frontend/src/lib/
├── api/
│   └── apps.js                    # AppRow contract definition
└── permissions/
    ├── policies.js                # Permission policies
    └── PermissionGate.jsx         # Permission gating component
```

## Component Details

### AppsShellView.jsx
**Purpose**: Thin layout shell that provides the page structure.

**Props**:
- `title` (string): Page title
- `menuItems` (array): Menu items for create button dropdown
- `searchValue` (string): Current search value
- `onSearch` (function): Search handler
- `footer` (node): Footer component (e.g., pagination)
- `contentSlot` (node, required): Main content area
- `toolbarSlot` (node, optional): Toolbar above content
- `breadcrumbsSlot` (node, optional): Breadcrumbs above header

**Responsibilities**:
- Composes AppsPageLayout + PageContainer + ResourcePageHeader
- Provides slots for extensibility
- No data logic, pure presentation

**Usage**:
```jsx
<AppsShellView
  title="Applications"
  menuItems={[...]}
  searchValue={search}
  onSearch={handleSearch}
  footer={<TablePaginationFooter />}
  contentSlot={<AppsTabs />}
/>
```

### AppsTabs.jsx
**Purpose**: Tabbed content area for Apps and Modules tabs.

**Props**:
- `table` (object): React-table instance
- `appsEmpty` (boolean): Whether apps tab should show empty state
- `modulesEmpty` (boolean): Whether modules tab should show empty state
- `emptyAppsSlot` (node): Empty state component for apps tab
- `emptyModulesSlot` (node): Empty state component for modules tab

**Responsibilities**:
- Manages tab switching (apps/modules)
- Manages view switching (list/grid)
- Conditionally hides header when empty
- Renders appropriate view (table/grid/empty)

**Empty State Logic**:
- If `appsEmpty` is true: shows `emptyAppsSlot`, hides header/filters
- If `modulesEmpty` is true: shows `emptyModulesSlot`, hides header/filters
- Otherwise: shows table/grid with filters

### AppsPage.columns.js
**Purpose**: Factory function that creates table column definitions.

**Signature**:
```javascript
appsColumns(deps = {})
```

**Dependencies** (`deps`):
- `perms` (object): Permission object with `canEdit`, `canPlay`, `canImport`
- `formatDate` (function, optional): Date formatter function
- `onPlay` (function, optional): Play button handler
- `onEdit` (function, optional): Edit button handler

**Returns**: Array of column definitions for react-table

**Column Structure**:
1. **Select column**: Checkbox for row selection
2. **Name column**: App name with link
3. **Last edited column**: Formatted date
4. **Edited by column**: User name
5. **Actions column**: Play, Edit, More menu buttons

**Pattern**: Factory function allows columns to be created with different dependencies (permissions, handlers) without coupling to specific implementations.

### useAppsTableState.js
**Purpose**: Headless hook that manages react-table state.

**Props**:
- `data` (array): Table data
- `columns` (array): Column definitions
- `initial` (object): Initial state (pagination, sorting, filters, etc.)
- `onPaginationChange` (function, optional): Callback for pagination changes

**Returns**:
- `table`: React-table instance
- `getSearch()`: Get current search value
- `setSearch(value)`: Set search value
- `state`: Current table state (pagination, sorting, filters, etc.)

**State Management**:
- Manages: row selection, column visibility, column filters, sorting, pagination, global filter (search)
- Syncs with external state via callbacks
- Memoizes data and columns for performance

### useAppsPageAdapter.js
**Purpose**: Extracts adapter logic into a reusable hook.

**Inputs** (HomePage state/methods):
- `apps`: Apps array
- `isLoading`: Loading state
- `error`: Error state
- `meta`: Pagination metadata
- `currentFolder`: Current folder
- `appSearchKey`: Search query
- `appType`: 'front-end' | 'module' | 'workflow'
- `canCreateApp`, `canUpdateApp`, `canDeleteApp`: Permission functions
- `pageChanged`, `onSearch`: Callbacks
- `columns`: Table columns (created in component)

**Outputs**:
- `appRows`: Transformed app data
- `perms`: Permission object
- `table`: React-table instance
- `getSearch`, `handleSearch`: Search handlers
- `handlePaginationChange`: Pagination handler
- `appsEmpty`, `modulesEmpty`: Empty state flags
- `error`, `isLoading`: State flags

**Key Features**:
- Transforms data using `transformAppsToAppRow`
- Computes permissions from HomePage methods
- Syncs HomePage state → Table state (bidirectional)
- Handles pagination conversion (1-indexed ↔ 0-indexed)
- Computes empty states

### AppsPageAdapter.jsx
**Purpose**: Bridge component that connects HomePage to new UI.

**Props Interface** (see INTEGRATION.md for complete list):
- State props: `apps`, `isLoading`, `error`, `meta`, `currentFolder`, `appSearchKey`, `appType`
- Method props: `pageChanged`, `folderChanged`, `onSearch`
- Permission props: `canCreateApp`, `canUpdateApp`, `canDeleteApp`
- Action props: `deleteApp`, `cloneApp`, `exportApp`
- Navigation props: `navigate` (optional, uses `useNavigate` if not provided)
- UI props: `darkMode`

**Responsibilities**:
1. **Prop Validation**: Runtime checks for required props
2. **Error Handling**: Try-catch error boundary, error UI
3. **Permission Mapping**: Maps HomePage methods to adapter perms
4. **Column Creation**: Creates columns with permissions and handlers
5. **Row Actions**: Wires play/edit/delete/clone to HomePage methods
6. **Navigation**: Handles navigation to app viewer/editor
7. **State Management**: Uses adapter hook for all logic
8. **Rendering**: Renders AppsShellView + AppsTabs

**Row Actions**:
- **Play**: Navigates to `/:workspaceId/applications/:slug`
- **Edit**: Navigates to `/:workspaceId/apps/:slug`
- **Delete**: Calls `deleteApp(_originalApp)` with confirmation
- **Clone**: Calls `cloneApp(_originalApp)`

**Error States**:
- Invalid props → Error UI with message
- Component errors → Error boundary catch with reload button
- API errors → Error UI with retry button

**Accessibility**:
- ARIA labels on error states
- ARIA labels on loading states
- ARIA labels on action buttons
- Screen reader friendly messages

### homePageToAppRow.js
**Purpose**: Transforms HomePage app objects to AppRow format.

**Input**: HomePage apps array
**Output**: AppRow array with `_originalApp` reference

**Transformation Mapping**:
- `app.id` → `id` (required, fallback to random if missing)
- `app.name` → `name` (fallback to 'Untitled App')
- `app.updated_at` / `app.updatedAt` / `app.created_at` → `lastEdited` (ISO string)
- `app.user?.name` / `app.user?.email` / `app.updated_by?.name` → `editedBy`
- `app.slug` → `slug`
- `app.icon` → `icon`
- `app.is_public` → `isPublic`
- `app.folder_id` → `folderId`
- `app.user_id` / `app.user?.id` → `userId`
- `app` (entire object) → `_originalApp` (critical for permissions/actions)

**Edge Cases Handled**:
- Missing fields with fallbacks
- Invalid date formats
- Missing user information
- Null/undefined arrays
- Malformed data

## Data Flow

### View-Only Flow (Storybook)
```
data.json
  → appsColumns({})
  → useAppsTableState({ data, columns })
  → AppsShellView + AppsTabs
```

### Container Flow (Future)
```
useAppsQuery()
  → data
  → useAppsPermissions()
  → perms
  → appsColumns({ perms })
  → useAppsTableState({ data, columns })
  → AppsPageContainer
  → AppsShellView + AppsTabs
```

### Adapter Flow (Current Integration)
```
HomePage state/methods
  → AppsPageAdapter
  → useAppsPageAdapter (transforms data, computes perms)
  → appsColumns({ perms, onPlay, onEdit })
  → useAppsTableState({ data: appRows, columns })
  → AppsShellView + AppsTabs
```

## State Management

### HomePage State (Source of Truth)
- `apps`: Array of app objects
- `isLoading`: Boolean
- `error`: Error object or null
- `meta`: `{ current_page, total_pages, total_count, per_page }`
- `currentFolder`: `{ id, name, ... }`
- `appSearchKey`: String

### Table State (Derived)
- `pagination`: Converted from `meta.current_page` (1-indexed → 0-indexed)
- `globalFilter`: Synced from `appSearchKey`
- `sorting`, `columnFilters`, `rowSelection`: Managed internally

### State Synchronization
**HomePage → Table** (via `useEffect`):
- `appSearchKey` changes → `table.setGlobalFilter()`
- `meta.current_page` changes → `table.setPageIndex()`

**Table → HomePage** (via callbacks):
- Table pagination changes → `pageChanged(newPage)`
- Table search changes → `onSearch(value)`

## Permission Model

### Permission Checks
All permission checks use the **original app object** (`_originalApp`), not the transformed AppRow.

**Why**: HomePage permission methods expect the original app structure.

**Mapping**:
- `canCreateApp()` → `perms.canImport` (boolean)
- `canUpdateApp(_originalApp)` → `perms.canEdit(appRow)` (function)
- `canUpdateApp(_originalApp)` → `perms.canPlay(appRow)` (function)
- `canDeleteApp(_originalApp)` → Used in row actions (not in perms object)

### Permission Usage
- **Menu items**: `perms.canImport` controls import button visibility
- **Column actions**: `perms.canEdit(appRow)` controls edit button state
- **Column actions**: `perms.canPlay(appRow)` controls play button state
- **Row actions**: `canDeleteApp(_originalApp)` controls delete option visibility

## Empty State Logic

### First-Time Empty
**Condition**: `apps.length === 0 && !hasQuery && !isLoading`

**hasQuery** = `!!(appSearchKey?.trim() || currentFolder?.id)`

**Behavior**:
- Shows `EmptyNoApps` component
- Hides table/filters/header
- Shows page header (create buttons)

### No Results
**Condition**: `hasQuery && table.getRowModel().rows.length === 0`

**Behavior**:
- Shows table with "No results." message
- Keeps filters/header visible
- User can clear search/filter to see all apps

### Tab-Scoped Empty
- **Apps tab**: `appsEmpty` flag controls empty state
- **Modules tab**: `modulesEmpty` flag controls empty state
- Each tab can have different empty states independently

## URL State Sync (Future)

### Current Implementation
- Uses HomePage state as source of truth
- No URL sync (deferred to future)

### Future Implementation
`useAppsUrlState` hook exists but not used in adapter:
- Syncs: search, sorting, pagination, filters to URL
- Enables: deep links, back/forward navigation, bookmarkable states
- Will be integrated in Phase 2-3 of migration

## Performance Optimizations

### Memoization
1. **appRows**: Memoized in `useAppsPageAdapter` (deps: `apps`)
2. **perms**: Memoized in `useAppsPageAdapter` (deps: `canCreateApp`, `canUpdateApp`)
3. **columns**: Memoized in `AppsPageAdapter` (deps: `computedPerms`, `handlePlay`, `handleEdit`)
4. **tablePagination**: Memoized in `useAppsPageAdapter` (deps: `meta.current_page`, `meta.per_page`)
5. **handlers**: Memoized with `useCallback` (proper deps)

### React.memo
- `AppsPageAdapter` wrapped in `React.memo` to prevent unnecessary re-renders

### Virtual Scrolling (Future)
- Large datasets (>1000 items) may benefit from virtual scrolling
- Can be added to `AppsTable` component without changing API

## Error Handling

### Levels of Error Handling

1. **Component Level** (AppsPageAdapter):
   - Try-catch wrapper around entire render
   - Catches unexpected errors
   - Shows error UI with reload button

2. **Hook Level** (useAppsPageAdapter):
   - Try-catch in data transformation
   - Try-catch in permission checks
   - Graceful fallbacks (empty arrays, default perms)

3. **Prop Validation**:
   - Runtime checks for required props
   - Type validation with PropTypes
   - User-friendly error messages

### Error States
- **Invalid props**: Shows error UI, doesn't crash
- **Transformation errors**: Logs error, returns empty array
- **Permission errors**: Logs error, defaults to false
- **Navigation errors**: Logs error, falls back to window.location

## Accessibility

### ARIA Attributes
- Error states: `role="alert"`, `aria-live="polite"`, `aria-atomic="true"`
- Loading states: `aria-live="polite"`, `aria-busy="true"`
- Action buttons: `aria-label` attributes
- Error descriptions: `id` attributes for association

### Keyboard Navigation
- Table supports keyboard navigation (react-table default)
- Action buttons are keyboard accessible
- Focus management handled by UI components

### Screen Reader Support
- All interactive elements have descriptive labels
- Error messages are announced
- Loading states are announced
- Empty states are descriptive

## Testing Strategy

### Unit Tests
- **Transformer**: `homePageToAppRow.test.js`
  - Valid data transformation
  - Missing fields handling
  - Date format handling
  - Original app preservation

- **Adapter Hook**: `useAppsPageAdapter.test.js`
  - Permission computation
  - State synchronization
  - Pagination conversion
  - Empty state computation

### Integration Tests
- **Adapter Component**: `AppsPageAdapter.test.jsx`
  - Props validation
  - Error handling
  - Row actions
  - Navigation

### Visual Tests
- **Storybook Stories**: Multiple scenarios
  - Default state
  - Loading state
  - Error state
  - Empty state
  - Pagination
  - Permissions

## Integration Points

### HomePage Integration
**Location**: `frontend/src/HomePage/HomePage.jsx`

**Replacement**:
Replace the existing UI rendering in `HomePage.render()` with:
```jsx
<AppsPageAdapter
  apps={this.state.apps}
  isLoading={this.state.isLoading}
  error={this.state.error}
  meta={this.state.meta}
  currentFolder={this.state.currentFolder}
  appSearchKey={this.state.appSearchKey}
  appType={this.props.appType}
  pageChanged={this.pageChanged}
  folderChanged={this.folderChanged}
  onSearch={(key) => this.fetchApps(1, this.state.currentFolder.id, key)}
  canCreateApp={this.canCreateApp}
  canDeleteApp={this.canDeleteApp}
  canUpdateApp={this.canUpdateApp}
  deleteApp={this.deleteApp}
  cloneApp={this.cloneApp}
  exportApp={this.exportApp}
  navigate={this.props.navigate}
  darkMode={this.props.darkMode}
/>
```

### What Still Needs HomePage UI
- Modals (create, clone, import, template)
- Folder management UI
- Git repository import
- Bulk actions
- App type tabs (if using separate routes)

## Patterns Used

### 1. Container/Presentational Pattern
- **Presentational**: AppsShellView, AppsTabs, AppsTable, AppsGrid
- **Container**: AppsPageContainer (future), AppsPageAdapter (current)

### 2. Hook Pattern
- Business logic extracted to hooks
- Hooks are pure functions (no side effects in hooks themselves)
- Hooks return state and handlers

### 3. Factory Pattern
- `appsColumns(deps)`: Creates columns with dependencies
- Allows different column configurations without code duplication

### 4. Adapter Pattern
- `AppsPageAdapter`: Bridges HomePage to new UI
- `homePageToAppRow`: Transforms data format
- Enables zero-effort integration

### 5. Slot Pattern
- `contentSlot`, `toolbarSlot`, `breadcrumbsSlot`: Extensibility points
- Allows customization without modifying components

### 6. Memoization Pattern
- Extensive use of `useMemo` and `useCallback`
- Prevents unnecessary re-renders
- Optimizes performance

## Best Practices

### 1. Component Design
- ✅ Props-only, no side effects
- ✅ Single responsibility
- ✅ Composable and reusable
- ✅ Well-documented with JSDoc

### 2. Data Flow
- ✅ Unidirectional data flow
- ✅ Props down, callbacks up
- ✅ Clear data transformation boundaries

### 3. Error Handling
- ✅ Defensive programming
- ✅ Graceful degradation
- ✅ User-friendly error messages
- ✅ Logging for debugging

### 4. Performance
- ✅ Memoization where needed
- ✅ Stable references
- ✅ React.memo for expensive components

### 5. Accessibility
- ✅ ARIA attributes
- ✅ Keyboard navigation
- ✅ Screen reader support

### 6. Testing
- ✅ Unit tests for logic
- ✅ Integration tests for components
- ✅ Visual regression tests

## Future Enhancements

### Phase 1 (Current)
- ✅ Presentational components
- ✅ Adapter for HomePage integration
- ✅ Basic error handling
- ✅ Empty states

### Phase 2 (Planned)
- ⏳ URL state sync integration
- ⏳ Real API integration (replace static hooks)
- ⏳ Real permission system integration
- ⏳ Module data support

### Phase 3 (Future)
- ⏳ Virtual scrolling for large datasets
- ⏳ Advanced filtering
- ⏳ Bulk operations
- ⏳ Real-time updates
- ⏳ Advanced sorting

## Migration Path

### Current State
- New UI components created
- Adapter bridges HomePage to new UI
- Storybook stories available
- Integration guide documented

### Next Steps
1. Frontend team integrates adapter into HomePage
2. Test with real data
3. Add URL state sync (optional)

## Key Design Decisions

### 1. Why Separate Shell and Tabs?
**Decision**: Use `AppsShellView` + `AppsTabs` pattern

**Rationale**:
- Shell handles layout (header, search, footer)
- Tabs handle content (apps/modules tabs, view switcher)
- Better separation of concerns
- More flexible (can reuse shell for other pages)

### 2. Why Adapter Pattern?
**Decision**: Create `AppsPageAdapter` instead of directly modifying HomePage

**Rationale**:
- Zero effort for frontend team
- Can be tested independently
- Can be removed if needed
- Clear integration point

### 3. Why Preserve Original App?
**Decision**: Store `_originalApp` in transformed data

**Rationale**:
- Permission checks need original app structure
- Action handlers expect original app
- Avoids data loss during transformation
- Enables backward compatibility

### 4. Why Memoize Everything?
**Decision**: Extensive use of `useMemo` and `useCallback`

**Rationale**:
- Prevents unnecessary re-renders
- Optimizes performance with large datasets
- Stable references for hooks
- Better user experience

### 5. Why Two Permission Computations?
**Decision**: Compute perms in both component and hook

**Rationale**:
- Component needs perms to create columns
- Hook needs perms for consistency
- Can be optimized later (pass perms to hook)
- Current implementation works correctly

## Troubleshooting Guide

### Common Issues

1. **Apps not displaying**
   - Check: `apps` prop is an array
   - Check: Browser console for transformation errors
   - Check: Data format matches expected structure

2. **Permissions not working**
   - Check: Permission functions provided
   - Check: `_originalApp` preserved in transformed data
   - Check: Permission functions accept original app object

3. **Pagination not syncing**
   - Check: `pageChanged` callback provided
   - Check: `meta.current_page` updating correctly
   - Check: Pagination conversion (1-indexed ↔ 0-indexed)

4. **Search not working**
   - Check: `onSearch` callback provided
   - Check: `appSearchKey` updating in HomePage state
   - Check: Search debouncing (if implemented)

5. **Row actions not working**
   - Check: `navigate` function provided
   - Check: Action handlers provided
   - Check: Browser console for errors

6. **Empty state showing incorrectly**
   - Check: `isLoading` properly set to false
   - Check: `appSearchKey` or `currentFolder.id` set when query active
   - Check: Empty state logic: `apps.length === 0 && !hasQuery && !isLoading`

## File Reference

### Core Components
- `AppsShellView.jsx`: Layout shell
- `AppsTabs.jsx`: Tabbed content
- `AppsTable.jsx`: Table renderer
- `AppsGrid.jsx`: Grid renderer
- `ResourcePageHeader.jsx`: Page header
- `EmptyNoApps.jsx`: Empty state

### Hooks
- `useAppsTableState.js`: Table state management
- `useAppsPageAdapter.js`: Adapter logic
- `useAppsUrlState.js`: URL state sync (future)
- `useAppsQuery.js`: Data fetching (static)
- `useAppsPermissions.js`: Permission checks (static)

### Adapters
- `AppsPageAdapter.jsx`: HomePage adapter component
- `homePageToAppRow.js`: Data transformer

### Utilities
- `AppsPage.columns.js`: Column factory
- `TablePaginationFooter.jsx`: Pagination UI

### Documentation
- `INTEGRATION.md`: Integration guide
- `LLM.txt`: This file

### Stories
- `AppsPageContainer.stories.jsx`: Container stories
- `AppsPageAdapter.stories.jsx`: Adapter stories

## Code Examples

### Basic Usage (Storybook)
```jsx
import { AppsShellView } from './AppsShellView';
import { AppsTabs } from './AppsTabs';
import { appsColumns } from './AppsPage.columns';
import { useAppsTableState } from '@/features/apps/hooks/useAppsTableState';
import data from './data.json';

export const Default = () => {
  const columns = appsColumns({});
  const { table, getSearch, setSearch } = useAppsTableState({ data, columns });
  
  return (
    <AppsShellView
      title="Applications"
      searchValue={getSearch()}
      onSearch={setSearch}
      contentSlot={<AppsTabs table={table} />}
    />
  );
};
```

### Adapter Usage (HomePage)
```jsx
import { AppsPageAdapter } from '@/components/AppsPage/AppsPageAdapter';

// In HomePage.render()
<AppsPageAdapter
  apps={this.state.apps}
  isLoading={this.state.isLoading}
  meta={this.state.meta}
  appSearchKey={this.state.appSearchKey}
  appType={this.props.appType}
  pageChanged={this.pageChanged}
  onSearch={(key) => this.fetchApps(1, this.state.currentFolder.id, key)}
  canCreateApp={this.canCreateApp}
  canUpdateApp={this.canUpdateApp}
  canDeleteApp={this.canDeleteApp}
  deleteApp={this.deleteApp}
  navigate={this.props.navigate}
/>
```

### Custom Columns
```jsx
const columns = appsColumns({
  perms: {
    canImport: true,
    canEdit: (appRow) => canEditApp(appRow._originalApp),
    canPlay: (appRow) => canEditApp(appRow._originalApp),
  },
  formatDate: (date) => moment(date).format('MMM DD, YYYY'),
  onPlay: (appRow) => navigateToApp(appRow._originalApp, 'view'),
  onEdit: (appRow) => navigateToApp(appRow._originalApp, 'edit'),
});
```

## Dependencies

### External Libraries
- `@tanstack/react-table`: Table state management
- `react-router-dom`: Navigation (via `useNavigate`)
- `lucide-react`: Icons
- `prop-types`: Runtime type checking

### Internal Dependencies
- `@/components/ui/*`: Design system components
- `@/_helpers/utils`: Utility functions (getWorkspaceId)
- `@/_services`: Service layer (for future API integration)

## Performance Considerations

### Optimization Strategies
1. **Memoization**: All computed values memoized
2. **Stable References**: Handlers use `useCallback`
3. **React.memo**: Expensive components wrapped
4. **Lazy Loading**: Can add code splitting if needed
5. **Virtual Scrolling**: Can add for large datasets

### Performance Metrics
- Initial render: Fast (memoized components)
- Re-renders: Minimal (stable references)
- Memory: Efficient (no unnecessary state)
- Bundle size: Acceptable (can be optimized)

## Security Considerations

### Permission Checks
- All permission checks use original app object
- No client-side permission bypass
- Permission functions are called with correct context

### Data Validation
- Input validation in transformer
- Prop validation in component
- Error handling prevents crashes

### XSS Prevention
- React handles escaping automatically
- No innerHTML usage
- User input sanitized (if needed)

## Browser Support

### Supported Browsers
- Chrome (latest)
- Firefox (latest)
- Safari (latest)
- Edge (latest)

### Features Used
- React Hooks (React 18+)
- ES6+ features
- Modern CSS (Tailwind)
- No polyfills needed (if React 18+)

## Contributing

### Adding New Features
1. Follow separation of concerns
2. Keep components pure
3. Extract logic to hooks
4. Add tests
5. Update documentation

### Code Style
- Use functional components
- Use hooks for state
- Memoize expensive computations
- Add JSDoc comments
- Follow existing patterns

### Testing
- Write unit tests for hooks
- Write integration tests for components
- Add Storybook stories
- Test edge cases

## Conclusion

The Apps Page architecture follows modern React patterns with strict separation of concerns. The adapter pattern enables seamless integration with existing HomePage code while maintaining clean, testable, and maintainable new components. The design system components remain pure and reusable, while the adapter layer handles the complexity of bridging old and new systems.

Key strengths:
- Clear architecture and patterns
- Excellent separation of concerns
- Comprehensive error handling
- Performance optimized
- Well documented
- Easy to test
- Accessible by default

The implementation is production-ready and can be integrated into HomePage with minimal effort from the frontend team.

