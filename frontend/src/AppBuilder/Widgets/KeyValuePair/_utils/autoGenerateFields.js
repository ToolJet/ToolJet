import { v4 as uuidv4 } from 'uuid';

/**
 * Auto-generate fields from data object keys
 * Similar to Table's autoGenerateColumns with deletion history tracking
 *
 * @param {Object} data - The data object to generate fields from
 * @param {Array} existingFields - Current field configurations
 * @param {Array} fieldDeletionHistory - Keys of fields that were manually deleted
 * @param {boolean} useDynamicField - Whether dynamic field mode is enabled
 * @param {Array} dynamicFieldData - Dynamic field configuration when useDynamicField is true
 * @returns {Array} - Generated field configurations
 */
export default function autoGenerateFields(
  data = {},
  existingFields = [],
  fieldDeletionHistory = [],
  useDynamicField = false,
  dynamicFieldData = []
) {
  // If using dynamic fields, return the dynamic field data directly
  if (useDynamicField) {
    if (dynamicFieldData.length > 0 && dynamicFieldData[0]?.name) {
      return dynamicFieldData.map((item) => ({
        ...item,
        id: item?.id ?? uuidv4(),
        name: item?.name,
        key: item?.key || item?.name,
        autogenerated: true,
      }));
    }
    return [];
  }

  // Get all keys from the data object
  const keysOfData = Object.keys(data || {});

  // Get keys of existing fields
  const keysOfExistingFields = existingFields.map((field) => field?.key || field?.name);

  // Find new keys that don't have existing fields AND are not in deletion history
  const newKeys = keysOfData.filter(
    (key) => !keysOfExistingFields.includes(key) && !fieldDeletionHistory.includes(key)
  );

  // Generate new field objects for new keys
  const generatedFields = newKeys.map((key) => ({
    id: uuidv4(),
    name: formatFieldName(key),
    key: key,
    fieldType: inferFieldType(data[key]),
    autogenerated: true,
  }));

  // Keep existing fields that are either:
  // 1. Not autogenerated (user-created)
  // 2. Autogenerated AND their key still exists in data AND not in deletion history
  const persistingFields = existingFields.filter((field) => {
    const fieldKey = field.key || field.name;
    // Always keep non-autogenerated (user-created) fields
    if (!field.autogenerated) return true;
    // For autogenerated fields: keep if key exists in data AND not in deletion history
    return keysOfData.includes(fieldKey) && !fieldDeletionHistory.includes(fieldKey);
  });

  // Combine persisting fields with newly generated ones
  return [...persistingFields, ...generatedFields];
}

/**
 * Format a key into a human-readable field name
 * e.g., "firstName" -> "First Name", "user_email" -> "User Email"
 */
function formatFieldName(key) {
  return key
    .replace(/_/g, ' ')
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (str) => str.toUpperCase())
    .trim();
}

/**
 * Infer the field type from the value
 */
function inferFieldType(value) {
  if (typeof value === 'boolean') return 'boolean';
  if (typeof value === 'number') return 'number';
  if (Array.isArray(value)) return 'string'; // Could be enhanced to detect multiSelect
  return 'string';
}
