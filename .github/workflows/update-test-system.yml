name: Update test system (LTS and pre-release)

on:
  workflow_dispatch:
    inputs:
      operation_mode:
        description: "What do you want to do?"
        required: true
        type: choice
        options:
          - view-env-vars          # Just view current .env
          - manage-env-vars        # Add/Edit/Remove env vars
          - deploy-docker-image    # Build & deploy new image
          - deploy-with-env-update # Deploy image + update env vars
      
      # Existing inputs for Docker deployment
      branch_name:
        description: "Git branch to build from (required for deploy operations)"
        required: false
        default: "main"
      dockerfile_path:
        description: "Select Dockerfile (required for deploy operations)"
        required: false
        type: choice
        options:
          - ./docker/LTS/ee/ee-production.Dockerfile
          - ./docker/pre-release/ee/ee-production.Dockerfile
      docker_tag:
        description: "Docker tag suffix (required for deploy operations)"
        required: false
      
      # Environment management inputs
      env_changes:
        description: "Environment changes (required for manage-env-vars). Format: ADD KEY=value, EDIT KEY=value, REMOVE KEY (one per line)"
        required: false
        default: ""
      
      test_system:
        description: "Select test system"
        required: true
        type: choice
        options:
          - app-builder-3.16-lts
          - app-builder-pre-release
          - platform-3.16-lts
          - platform-pre-release
          - marketplace-3.16-lts
          - marketplace-pre-release
          - ai-3.16-lts
          - ai-pre-release

jobs:
  # Job 1: View current environment variables
  view-environment:
    if: github.event.inputs.operation_mode == 'view-env-vars'
    runs-on: ubuntu-latest

    steps:
      - name: âœ… Check user authorization
        run: |
          # Define allowed users
          allowed_users=(
            "${{ secrets.ALLOWED_USER1_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER2_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER3_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER4_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER5_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER6_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER7_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER8_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER9_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER10_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER11_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER12_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER13_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER14_TEST_SYSTEM }}"
          )

          current_user="${{ github.actor }}"
          authorized=false

          for user in "${allowed_users[@]}"; do
            if [[ "$current_user" == "$user" ]]; then
              authorized=true
              break
            fi
          done

          if [[ "$authorized" == "false" ]]; then
            echo "âŒ User '$current_user' is not authorized to trigger this workflow."
            exit 1
          else
            echo "âœ… User '$current_user' is authorized."
          fi

      - name: Install SSH and JQ
        run: sudo apt-get install -y jq openssh-client

      - name: Determine target host
        id: vmhost
        run: |
          test_system="${{ github.event.inputs.test_system }}"
          vm_host=$(echo '${{ secrets.VM_HOST_MAP_JSON }}' | jq -r --arg sys "$test_system" '.[$sys]')

          if [[ -z "$vm_host" || "$vm_host" == "null" ]]; then
            echo "VM mapping not found for $test_system"
            exit 1
          fi

          echo "host=$vm_host" >> $GITHUB_OUTPUT

      - name: View current .env file
        run: |
          echo "$SSH_KEY" > key.pem
          chmod 600 key.pem

          TARGET_SYSTEM="${{ github.event.inputs.test_system }}"

          ssh -o StrictHostKeyChecking=no -i key.pem $SSH_USER@${{ steps.vmhost.outputs.host }} << 'EOF'
          set -e

          TARGET_SYSTEM="$TARGET_SYSTEM"
          cd ~

          # Navigate to correct directory
          if [[ "$TARGET_SYSTEM" == *-3.16-lts ]]; then
            echo "ğŸ” Detected LTS system, navigating to LTS directory..."
            LTS_DIRS=$(ls -1d ./*-lts 2>/dev/null | grep -E '[0-9]+\.[0-9]+' | sed 's|^\./||' | sort -V)
            if [[ -z "$LTS_DIRS" ]]; then
              echo "âŒ No LTS directories found!"
              exit 1
            fi
            SELECTED_LTS_DIR=$(echo "$LTS_DIRS" | head -n 1)
            cd "$SELECTED_LTS_DIR"
            echo "ğŸ“‚ Working in LTS directory: $(pwd)"
          else
            echo "ğŸ“‚ Working in home directory: $(pwd)"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“‹ Current .env file for: $TARGET_SYSTEM"
          echo "ğŸ“‚ Location: $(pwd)/.env"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ”’ PROTECTED VARIABLES (Hidden - Not Editable):"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Protected variables that cannot be viewed or edited
          PROTECTED_VARS="TOOLJET_HOST|LOCKBOX_MASTER_KEY|SECRET_KEY_BASE|ORM_LOGGING|PG_DB|PG_USER|PG_HOST|PG_PASS|TOOLJET_DB|TOOLJET_DB_USER|TOOLJET_DB_HOST|TOOLJET_DB_PASS|PGRST_DB_URI|PGRST_HOST|PGRST_JWT_SECRET|PGRST_SERVER_PORT|REDIS_HOST|REDIS_PORT|REDIS_USER|REDIS_PASSWORD|OLD_IMAGE|TOOLJET_IMAGE"

          # Show protected variable keys (values hidden)
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Extract key
            KEY=$(echo "$line" | cut -d'=' -f1)
            
            # Check if it's a protected variable
            if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
              echo "$KEY=***HIDDEN***"
            fi
          done < .env

          echo ""
          echo "âœï¸  OPTIONAL VARIABLES (You Can View and Edit):"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Show all non-protected variables
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Extract key
            KEY=$(echo "$line" | cut -d'=' -f1)
            
            # Skip if it's a protected variable
            if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
              continue
            fi
            
            # Show the full line for optional variables
            echo "$line"
          done < .env

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          TOTAL_VARS=$(grep -c '^[^#]' .env 2>/dev/null || echo "0")
          PROTECTED_COUNT=$(grep -E "^($PROTECTED_VARS)=" .env 2>/dev/null | wc -l)
          EDITABLE_COUNT=$((TOTAL_VARS - PROTECTED_COUNT))
          
          echo "ğŸ“Š Summary:"
          echo "   Total variables: $TOTAL_VARS"
          echo "   ğŸ”’ Protected: $PROTECTED_COUNT"
          echo "   âœï¸  Editable: $EDITABLE_COUNT"
          echo ""
          echo "ğŸ’¡ Usage Tips:"
          echo "   - To edit variables: Use 'manage-env-vars' operation mode"
          echo "   - Format: ADD KEY=value, EDIT KEY=value, REMOVE KEY"
          echo "   - Protected variables cannot be modified for security"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          EOF
        env:
          SSH_USER: ${{ secrets.AZURE_VM_USER }}
          SSH_KEY: ${{ secrets.AZURE_VM_KEY }}

  # Job 2: Manage environment variables only
  manage-environment:
    if: github.event.inputs.operation_mode == 'manage-env-vars'
    runs-on: ubuntu-latest

    steps:
      - name: âœ… Check user authorization
        run: |
          # Define allowed users
          allowed_users=(
            "${{ secrets.ALLOWED_USER1_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER2_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER3_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER4_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER5_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER6_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER7_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER8_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER9_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER10_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER11_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER12_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER13_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER14_TEST_SYSTEM }}"
          )

          current_user="${{ github.actor }}"
          authorized=false

          for user in "${allowed_users[@]}"; do
            if [[ "$current_user" == "$user" ]]; then
              authorized=true
              break
            fi
          done

          if [[ "$authorized" == "false" ]]; then
            echo "âŒ User '$current_user' is not authorized to trigger this workflow."
            exit 1
          else
            echo "âœ… User '$current_user' is authorized."
          fi

      - name: Validate env_changes input
        run: |
          if [[ -z "${{ github.event.inputs.env_changes }}" ]]; then
            echo "âŒ Error: env_changes input is required for manage-env-vars operation"
            echo "ğŸ’¡ Tip: Use format like:"
            echo "   ADD NEW_VAR=value"
            echo "   EDIT EXISTING_VAR=new_value"
            echo "   REMOVE OLD_VAR"
            exit 1
          fi

      - name: Install SSH and JQ
        run: sudo apt-get install -y jq openssh-client

      - name: Determine target host
        id: vmhost
        run: |
          test_system="${{ github.event.inputs.test_system }}"
          vm_host=$(echo '${{ secrets.VM_HOST_MAP_JSON }}' | jq -r --arg sys "$test_system" '.[$sys]')

          if [[ -z "$vm_host" || "$vm_host" == "null" ]]; then
            echo "VM mapping not found for $test_system"
            exit 1
          fi

          echo "host=$vm_host" >> $GITHUB_OUTPUT

      - name: Update environment variables
        run: |
          echo "$SSH_KEY" > key.pem
          chmod 600 key.pem

          TARGET_SYSTEM="${{ github.event.inputs.test_system }}"
          ENV_CHANGES="${{ github.event.inputs.env_changes }}"

          ssh -o StrictHostKeyChecking=no -i key.pem $SSH_USER@${{ steps.vmhost.outputs.host }} << 'EOF'
          set -e

          TARGET_SYSTEM="$TARGET_SYSTEM"
          ENV_CHANGES="$ENV_CHANGES"

          cd ~

          # Navigate to correct directory
          if [[ "$TARGET_SYSTEM" == *-3.16-lts ]]; then
            echo "ğŸ” Detected LTS system, navigating to LTS directory..."
            LTS_DIRS=$(ls -1d ./*-lts 2>/dev/null | grep -E '[0-9]+\.[0-9]+' | sed 's|^\./||' | sort -V)
            if [[ -z "$LTS_DIRS" ]]; then
              echo "âŒ No LTS directories found!"
              exit 1
            fi
            SELECTED_LTS_DIR=$(echo "$LTS_DIRS" | head -n 1)
            cd "$SELECTED_LTS_DIR"
            echo "ğŸ“‚ Working in LTS directory: $(pwd)"
          else
            echo "ğŸ“‚ Working in home directory: $(pwd)"
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ”§ PROCESSING ENVIRONMENT VARIABLE CHANGES"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Backup .env before modifications
          echo "ğŸ’¾ Creating .env backup"
          BACKUP_FILE=".env.backup.$(date +%s)"
          sudo cp .env "$BACKUP_FILE"
          echo "âœ… Backup created: $BACKUP_FILE"
          echo ""

          # Define protected variables (cannot be modified)
          PROTECTED_VARS="TOOLJET_HOST|LOCKBOX_MASTER_KEY|SECRET_KEY_BASE|ORM_LOGGING|PG_DB|PG_USER|PG_HOST|PG_PASS|TOOLJET_DB|TOOLJET_DB_USER|TOOLJET_DB_HOST|TOOLJET_DB_PASS|PGRST_DB_URI|PGRST_HOST|PGRST_JWT_SECRET|PGRST_SERVER_PORT|REDIS_HOST|REDIS_PORT|REDIS_USER|REDIS_PASSWORD|OLD_IMAGE|TOOLJET_IMAGE"

          echo "ğŸ“ Current .env snapshot (showing only editable variables):"
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            KEY=$(echo "$line" | cut -d'=' -f1)
            
            # Skip protected variables in display
            if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
              continue
            fi
            
            echo "$line"
          done < .env | head -15
          echo ""

          # Process each line of env_changes
          while IFS= read -r line; do
            # Trim whitespace
            line=$(echo "$line" | xargs)

            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            # Process ADD command
            if [[ "$line" =~ ^ADD[[:space:]]+([^=]+)=(.*)$ ]]; then
              KEY="${BASH_REMATCH[1]}"
              VALUE="${BASH_REMATCH[2]}"

              # Check if trying to add a protected variable
              if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                echo "âŒ ERROR: Cannot add/modify protected variable: $KEY"
                echo "ğŸ”’ Protected variables are managed by the deployment system and cannot be changed"
                echo "ğŸ’¡ Use 'view-env-vars' to see which variables you can edit"
                exit 1
              fi

              if grep -q "^${KEY}=" .env; then
                echo "âš ï¸  Variable '$KEY' already exists, skipping ADD (use EDIT to modify)"
              else
                echo "â• Adding: $KEY=$VALUE"
                echo "${KEY}=${VALUE}" | sudo tee -a .env > /dev/null
              fi

            # Process EDIT command
            elif [[ "$line" =~ ^EDIT[[:space:]]+([^=]+)=(.*)$ ]]; then
              KEY="${BASH_REMATCH[1]}"
              VALUE="${BASH_REMATCH[2]}"

              # Check if trying to edit a protected variable
              if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                echo "âŒ ERROR: Cannot edit protected variable: $KEY"
                echo "ğŸ”’ Protected variables are managed by the deployment system and cannot be changed"
                echo "ğŸ’¡ Use 'view-env-vars' to see which variables you can edit"
                exit 1
              fi

              if grep -q "^${KEY}=" .env; then
                echo "âœï¸  Editing: $KEY=$VALUE"
                sudo sed -i "s|^${KEY}=.*|${KEY}=${VALUE}|" .env
              else
                echo "âš ï¸  Variable '$KEY' not found, skipping EDIT (use ADD to create)"
              fi

            # Process REMOVE command
            elif [[ "$line" =~ ^REMOVE[[:space:]]+([^=[:space:]]+)$ ]]; then
              KEY="${BASH_REMATCH[1]}"

              # Check if variable is protected
              if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                echo "âŒ ERROR: Cannot remove protected variable: $KEY"
                echo "ğŸ”’ Protected variables are managed by the deployment system and cannot be removed"
                echo "ğŸ’¡ Use 'view-env-vars' to see which variables you can edit"
                exit 1
              fi

              if grep -q "^${KEY}=" .env; then
                echo "â– Removing: $KEY"
                sudo sed -i "/^${KEY}=/d" .env
              else
                echo "âš ï¸  Variable '$KEY' not found, skipping REMOVE"
              fi

            else
              echo "âš ï¸  Invalid format: $line"
              echo "Valid formats: ADD KEY=value, EDIT KEY=value, REMOVE KEY"
            fi

          done <<< "$ENV_CHANGES"

          echo ""
          echo "ğŸ“„ Modified .env preview (showing only editable variables):"
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            KEY=$(echo "$line" | cut -d'=' -f1)
            
            if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
              continue
            fi
            
            echo "$line"
          done < .env | tail -20
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Restart containers to apply changes
          echo ""
          echo "ğŸ”„ Restarting containers to apply changes..."
          sudo docker-compose down
          
          echo "ğŸš€ Starting containers..."
          sudo docker-compose up -d

          # Wait for containers to be healthy
          echo "â³ Waiting for containers to start (timeout: 120 seconds)..."
          SUCCESS_FOUND=false
          TIMEOUT=120
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            if sudo docker-compose logs 2>/dev/null | grep -qE "ğŸš€ TOOLJET APPLICATION STARTED SUCCESSFULLY|Ready to use at http://localhost:82 ğŸš€|Ready to use at http://localhost:80"; then
              echo "âœ… Containers started successfully!"
              SUCCESS_FOUND=true
              break
            fi
            
            echo "â³ Still waiting... (${ELAPSED}s elapsed)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done

          if [ "$SUCCESS_FOUND" = false ]; then
            echo "âŒ Container startup failed or timed out"
            echo "ğŸ“„ Last 20 lines of logs:"
            sudo docker-compose logs --tail=20
            echo ""
            
            echo "ğŸ›‘ Rolling back to previous .env state..."
            sudo cp "$BACKUP_FILE" .env
            echo "âœ… .env restored from backup"
            
            echo "ğŸ”„ Restarting with previous configuration..."
            sudo docker-compose down
            sudo docker-compose up -d
            
            # Wait a bit for rollback to complete
            echo "â³ Waiting for rollback to complete..."
            sleep 30
            
            echo "ğŸ“„ Rollback logs:"
            sudo docker-compose logs --tail=20
            echo ""
            echo "âœ… Rollback completed - system restored to previous state"
            exit 1
          fi

          echo ""
          echo "ğŸ“‹ Container status:"
          sudo docker-compose ps
          echo ""
          echo "ğŸ“„ Application logs (last 20 lines):"
          sudo docker-compose logs --tail=20
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Environment variables updated successfully!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Cleanup old backups (keep last 1)
          echo ""
          echo "ğŸ§¹ Cleaning up old backups (keeping last 1)..."
          ls -t .env.backup.* 2>/dev/null | tail -n +2 | xargs -r sudo rm -f
          echo "âœ… Cleanup complete"

          EOF
        env:
          SSH_USER: ${{ secrets.AZURE_VM_USER }}
          SSH_KEY: ${{ secrets.AZURE_VM_KEY }}

  # Job 3: Deploy Docker image only (original workflow)
  build-and-deploy:
    if: |
      github.event.inputs.operation_mode == 'deploy-docker-image' || 
      github.event.inputs.operation_mode == 'deploy-with-env-update'
    runs-on: ubuntu-latest

    steps:
      - name: Validate required inputs for deployment
        run: |
          if [[ -z "${{ github.event.inputs.branch_name }}" ]]; then
            echo "âŒ Error: branch_name is required for deploy operations"
            exit 1
          fi
          if [[ -z "${{ github.event.inputs.dockerfile_path }}" ]]; then
            echo "âŒ Error: dockerfile_path is required for deploy operations"
            exit 1
          fi
          if [[ -z "${{ github.event.inputs.docker_tag }}" ]]; then
            echo "âŒ Error: docker_tag is required for deploy operations"
            exit 1
          fi

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          sudo docker system prune -af
          sudo apt-get clean
          df -h

      - name: âœ… Check user authorization
        run: |
          # Define allowed users
          allowed_users=(
            "${{ secrets.ALLOWED_USER1_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER2_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER3_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER4_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER5_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER6_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER7_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER8_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER9_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER10_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER11_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER12_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER13_TEST_SYSTEM }}"
            "${{ secrets.ALLOWED_USER14_TEST_SYSTEM }}"
          )

          current_user="${{ github.actor }}"
          authorized=false

          for user in "${allowed_users[@]}"; do
            if [[ "$current_user" == "$user" ]]; then
              authorized=true
              break
            fi
          done

          if [[ "$authorized" == "false" ]]; then
            echo "âŒ User '$current_user' is not authorized to trigger this workflow."
            exit 1
          else
            echo "âœ… User '$current_user' is authorized."
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch_name }}
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Generate full Docker tag
        id: taggen
        run: |
          input_tag="${{ github.event.inputs.docker_tag }}"
          if [[ "$input_tag" == *"/"* ]]; then
            echo "tag=$input_tag" >> $GITHUB_OUTPUT
          else
            echo "tag=tooljet/tj-osv:$input_tag" >> $GITHUB_OUTPUT
          fi

      - name: Build and Push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ${{ github.event.inputs.dockerfile_path }}
          push: true
          tags: ${{ steps.taggen.outputs.tag }}
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            CUSTOM_GITHUB_TOKEN=${{ secrets.CUSTOM_GITHUB_TOKEN }}
            BRANCH_NAME=${{ github.event.inputs.branch_name }}

      - name: Show the full Docker tag
        run: echo "âœ… Docker image built and pushed:${{ steps.taggen.outputs.tag }}"

      - name: Install SSH and JQ
        run: sudo apt-get install -y jq openssh-client

      - name: Determine target host
        id: vmhost
        run: |
          test_system="${{ github.event.inputs.test_system }}"
          vm_host=$(echo '${{ secrets.VM_HOST_MAP_JSON }}' | jq -r --arg sys "$test_system" '.[$sys]')

          if [[ -z "$vm_host" || "$vm_host" == "null" ]]; then
            echo "VM mapping not found for $test_system"
            exit 1
          fi

          echo "host=$vm_host" >> $GITHUB_OUTPUT

      - name: Deploy to target environment
        run: |
          echo "$SSH_KEY" > key.pem
          chmod 600 key.pem

          IMAGE_TAG="${{ steps.taggen.outputs.tag }}"
          TARGET_SYSTEM="${{ github.event.inputs.test_system }}"
          ENV_CHANGES="${{ github.event.inputs.env_changes }}"
          OPERATION_MODE="${{ github.event.inputs.operation_mode }}"

          # Debug: Show what we're deploying
          echo "DEBUG: IMAGE_TAG=$IMAGE_TAG"
          echo "DEBUG: TARGET_SYSTEM=$TARGET_SYSTEM"
          echo "DEBUG: OPERATION_MODE=$OPERATION_MODE"

          ssh -o StrictHostKeyChecking=no -i key.pem $SSH_USER@${{ steps.vmhost.outputs.host }} << 'EOF'
          set -e

          IMAGE_TAG="$IMAGE_TAG"
          TARGET_SYSTEM="$TARGET_SYSTEM"
          ENV_CHANGES="$ENV_CHANGES"
          OPERATION_MODE="$OPERATION_MODE"

          cd ~
          echo "ğŸ“ Finding correct deployment directory"

          # Debug: Show variables on remote host
          echo "Debug on remote: IMAGE_TAG=$IMAGE_TAG"
          echo "Debug on remote: TARGET_SYSTEM=$TARGET_SYSTEM"

          if [[ "$TARGET_SYSTEM" == *-3.16-lts ]]; then
            echo "Detected LTS system: $TARGET_SYSTEM"
            echo "ğŸ” Searching for LTS directories..."
            
            # Find LTS directories dynamically
            LTS_DIRS=$(ls -1d ./*-lts 2>/dev/null | grep -E '[0-9]+\.[0-9]+' | sed 's|^\./||' | sort -V; \
                       ls -1d ./*-lts 2>/dev/null | grep -Ev '[0-9]+\.[0-9]+' | sed 's|^\./||' | sort)
            
            if [[ -z "$LTS_DIRS" ]]; then
              echo "âŒ No LTS directories found!"
              echo "Available directories:"
              ls -la | grep "^d"
              exit 1
            fi
            
            echo "Available LTS directories:"
            echo "$LTS_DIRS"
            
            # Choose the first available LTS directory
            SELECTED_LTS_DIR=$(echo "$LTS_DIRS" | head -n 1)
            
            echo "ğŸ“‚ Selected LTS directory: $SELECTED_LTS_DIR"
            cd "$SELECTED_LTS_DIR"
            echo "âœ… Now in directory: $(pwd)"
          else
            echo "Detected pre-release system: $TARGET_SYSTEM"
            echo "ğŸ“‚ Moving to target directory: $TARGET_SYSTEM"
            cd ~
            echo "âœ… Now in directory: $(pwd)"
          fi

          # Process environment variables if operation mode is deploy-with-env-update
          if [[ "$OPERATION_MODE" == "deploy-with-env-update" && -n "$ENV_CHANGES" ]]; then
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ”§ PROCESSING ENVIRONMENT VARIABLE CHANGES"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Backup .env before modifications
            echo "ğŸ’¾ Creating .env backup"
            BACKUP_FILE=".env.backup.$(date +%s)"
            sudo cp .env "$BACKUP_FILE"
            echo "âœ… Backup created: $BACKUP_FILE"
            echo ""

            # Define protected variables (cannot be modified via env_changes)
            # Note: TOOLJET_IMAGE is excluded here as it's updated by the deployment process
            PROTECTED_VARS="TOOLJET_HOST|LOCKBOX_MASTER_KEY|SECRET_KEY_BASE|ORM_LOGGING|PG_DB|PG_USER|PG_HOST|PG_PASS|TOOLJET_DB|TOOLJET_DB_USER|TOOLJET_DB_HOST|TOOLJET_DB_PASS|PGRST_DB_URI|PGRST_HOST|PGRST_JWT_SECRET|PGRST_SERVER_PORT|REDIS_HOST|REDIS_PORT|REDIS_USER|REDIS_PASSWORD|OLD_IMAGE|TOOLJET_IMAGE"

            # Process each line of env_changes
            while IFS= read -r line; do
              # Trim whitespace
              line=$(echo "$line" | xargs)

              # Skip empty lines and comments
              [[ -z "$line" || "$line" =~ ^# ]] && continue

              # Process ADD command
              if [[ "$line" =~ ^ADD[[:space:]]+([^=]+)=(.*)$ ]]; then
                KEY="${BASH_REMATCH[1]}"
                VALUE="${BASH_REMATCH[2]}"

                # Check if trying to add a protected variable
                if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                  echo "âŒ ERROR: Cannot add/modify protected variable: $KEY"
                  exit 1
                fi

                if grep -q "^${KEY}=" .env; then
                  echo "âš ï¸  Variable '$KEY' already exists, skipping ADD"
                else
                  echo "â• Adding: $KEY=$VALUE"
                  echo "${KEY}=${VALUE}" | sudo tee -a .env > /dev/null
                fi

              # Process EDIT command
              elif [[ "$line" =~ ^EDIT[[:space:]]+([^=]+)=(.*)$ ]]; then
                KEY="${BASH_REMATCH[1]}"
                VALUE="${BASH_REMATCH[2]}"

                # Check if trying to edit a protected variable
                if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                  echo "âŒ ERROR: Cannot edit protected variable: $KEY"
                  exit 1
                fi

                if grep -q "^${KEY}=" .env; then
                  echo "âœï¸  Editing: $KEY=$VALUE"
                  sudo sed -i "s|^${KEY}=.*|${KEY}=${VALUE}|" .env
                else
                  echo "âš ï¸  Variable '$KEY' not found, skipping EDIT"
                fi

              # Process REMOVE command
              elif [[ "$line" =~ ^REMOVE[[:space:]]+([^=[:space:]]+)$ ]]; then
                KEY="${BASH_REMATCH[1]}"

                # Check if variable is protected
                if echo "$KEY" | grep -qE "$PROTECTED_VARS"; then
                  echo "âŒ ERROR: Cannot remove protected variable: $KEY"
                  exit 1
                fi

                if grep -q "^${KEY}=" .env; then
                  echo "â– Removing: $KEY"
                  sudo sed -i "/^${KEY}=/d" .env
                else
                  echo "âš ï¸  Variable '$KEY' not found, skipping REMOVE"
                fi

              else
                echo "âš ï¸  Invalid format: $line"
              fi

            done <<< "$ENV_CHANGES"

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
          fi

          echo "ğŸ” Docker login"
          echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login --username "${{ secrets.DOCKER_USERNAME }}" --password-stdin

          echo "current image"
          cat .env | grep TOOLJET_IMAGE

          echo "ğŸ“¦ Reading current TOOLJET_IMAGE from .env"
          CURRENT_IMAGE=$(grep '^TOOLJET_IMAGE=' .env | cut -d '=' -f2- | tr -d '"' | tr -d "'")
          echo "Found CURRENT_IMAGE: $CURRENT_IMAGE"

          echo "ğŸ›‘ Stopping containers"
          sudo docker-compose down

          echo "ğŸ“ Updating .env with new image"
          sudo sed -i "s|^TOOLJET_IMAGE=.*|TOOLJET_IMAGE=$IMAGE_TAG|" .env

          echo "ğŸ“¥ Pulling new image: $IMAGE_TAG"
          if [ -z "$IMAGE_TAG" ]; then
            echo "âŒ IMAGE_TAG is empty!"
            exit 1
          fi
          sudo docker pull "$IMAGE_TAG"

          echo "ğŸš€ Starting container in background"
          sudo docker-compose up -d

          # Wait for ToolJet to start and show success message
          echo "â³ Waiting for ToolJet to start (timeout: 300 seconds)..."
          SUCCESS_FOUND=false
          TIMEOUT=300
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Check for success message in logs
            if sudo docker-compose logs 2>/dev/null | grep -qE "ğŸš€ TOOLJET APPLICATION STARTED SUCCESSFULLY|Ready to use at http://localhost:82 ğŸš€|Ready to use at http://localhost:80"; then
              echo "âœ… Found success message in logs!"
              SUCCESS_FOUND=true
              break
            fi
            
            echo "â³ Still waiting... (${ELAPSED}s elapsed)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done

          if [ "$SUCCESS_FOUND" = false ]; then
            echo "âŒ Timeout reached without finding success logs"
            echo "ğŸ“„ Showing current logs for troubleshooting..."
            sudo docker-compose logs --tail=50
            echo ""
            echo "=== CONTAINER STATUS ==="
            sudo docker-compose ps
            echo ""
            
            echo "ğŸ›‘ Starting rollback process..."
            sudo docker-compose down
            
            # If we have a backup from env changes, restore it
            if [[ "$OPERATION_MODE" == "deploy-with-env-update" && -n "$BACKUP_FILE" ]]; then
              echo "ğŸ”„ Restoring .env from backup: $BACKUP_FILE"
              sudo cp "$BACKUP_FILE" .env
            else
              echo "ğŸ”„ Reverting TOOLJET_IMAGE to previous version"
              sudo sed -i "s|^TOOLJET_IMAGE=.*|TOOLJET_IMAGE=$CURRENT_IMAGE|" .env
            fi
            
            echo "ğŸ”„ Starting previous image..."
            sudo docker-compose up -d
            echo "âœ… Rollback completed!"
            exit 1
          fi

          echo "âœ… Deployment successful!"

          echo "ğŸ“Œ Storing successful deployment info in .env"
          sudo sed -i "/^OLD_IMAGE=/d" .env
          echo "OLD_IMAGE=$CURRENT_IMAGE" | sudo tee -a .env
          echo "ğŸ“„ Final application logs:"
          sudo docker-compose logs --tail=50

          echo "ğŸ§¹ Pruning old Docker images"
          sudo docker image prune -a -f

          # Cleanup old backups if any were created
          if [[ "$OPERATION_MODE" == "deploy-with-env-update" ]]; then
            echo "ğŸ§¹ Cleaning up old .env backups (keeping last 1)"
            ls -t .env.backup.* 2>/dev/null | tail -n +2 | xargs -r sudo rm -f
          fi

          EOF
        env:
          SSH_USER: ${{ secrets.AZURE_VM_USER }}
          SSH_KEY: ${{ secrets.AZURE_VM_KEY }}
          